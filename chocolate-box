#!/usr/bin/env python3
# chocolate-box
# Copyright (c) 2022 Nicholas Girga
# Provides simple GUI for Chocolate DOOM.


# Imports
import enum, gi, os, subprocess, sys
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
gi.require_version('GdkPixbuf', '2.0')
from gi.repository import Gdk, GdkPixbuf, Gio, Gtk
from pathlib import Path


# Define main class.
class Main:


    # Ways that the launcher should behave after launching.
    class LaunchBehavior(enum.Enum):
        NONE = 0,           # launcher will do nothing after launch
        MINIMIZE = 1,       # launcher will minimize after launch and present itself after Chocolate DOOM exits
        STAY_MINIMIZED = 2, # launcher will minimize after launch
        EXIT = 3            # launcher will hide after launch and exit when Chocolate DOOM exits

    
    # The current version of this app.
    APP_VERSION = "1.0"

    
    # The relative path to the window icon that is not installed on the system.
    LOCAL_ICON = "./res/icon/icon_256.png"


    # The absolute path to the window icon that is installed on the system.
    SYSTEM_ICON = "/usr/share/icons/chocolate-box_256.png"


    # The relative path to the about logo that is not installed on the system.
    LOCAL_LOGO = "./res/icon/icon_128.png"


    # The absolute path to the about logo that is installed on the system.
    SYSTEM_LOGO = "/usr/share/icons/chocolate-box_128.png"


    # The relative path to the UI template that is not installed on the system.
    LOCAL_GLADE = "./chocolate-box.ui"


    # The absolute path to the UI template that is installed on the system.
    SYSTEM_GLADE = "/usr/share/chocolate-box/chocolate-box.ui"


    # How the launcher should behave after launching.
    launch_behavior = LaunchBehavior.EXIT


    # If extra information should be printed.
    verbose = False


    # A custom path to the Chocolate DOOM executable.
    executable = ""


    # The path to the Chocolate Box configuration directory.
    config_directory = os.path.expanduser("~") + "/.config/chocolate-box"


    # The path to the presets directory.
    presets_directory = config_directory + "/presets"


    # The path to the file that keeps track of the configured IWADs.
    iwads_file = config_directory + "/iwads"


    # The path to the file that keeps track of the configured PWADs.
    pwads_file = config_directory + "/pwads"

    
    # The paths to known IWADs.
    # This will be populated by the contents of the iwads_file when `update_iwad_list()` is called.
    iwad_paths = {}


    # The paths to known executables for IWADs
    # This will be populated by the contents of the iwads_file when `update_iwad_list()` is called.
    exec_paths = {}


    # The paths to known PWADs.
    # This will be populated by the contents of the pwads_file when `update_pwad_list()` is called.
    pwad_paths = {}


    # The path to the current configuration file.
    config_file = config_directory + "/chocolate-box.conf"


    # Initializes main class.
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        
        # check launch options
        args = sys.argv[1:]
        for arg in args:
            if len(arg) > 0:
                if arg[0] == '-':
                    # is an option
                    if len(arg) > 1:
                        if arg[1] == '-':
                            # is a double dash (word) option (e.g. `--help`)
                            if arg == "--help":
                                self.print_help() # show help
                                sys.exit(0)
                            if arg == "--version":
                                self.print_version() # show version
                                sys.exit(0)
                            if arg == "--verbose":
                                print(  "WARNING!: Verbose mode is enabled!\n" +
                                        "Extra information will be given.")
                                self.verbose = True # enable verbose mode
                            else:
                                print(  "ERROR!: Invalid option (" + arg + ")!\n" +
                                        "Use `chocolate-box --help` for more information.", ' ', '\n', file = sys.stderr)
                                sys.exit(1) # invalid option; exit with code 1
                        else:
                            # is a single dash/char option (e.g. `-v`)
                            for char in arg[1:]:
                                if char == 'h':
                                    self.print_help() # show help
                                    sys.exit(0)
                                else:
                                    print(  "ERROR!: Invalid option (-" + char + ")!\n" +
                                            "Use `chocolate-box --help` for more information.", ' ', '\n', file = sys.stderr)
                                    sys.exit(1) # invalid option; exit with code 1
                    else:
                        print(  "ERROR!: Invalid syntax (" + arg + ")!\n" +
                                "Use `chocolate-box --help` for more information.", ' ', '\n', file = sys.stderr)
                        sys.exit(2) # invalid syntax (-); exit with code 2
                else:
                    # is not an option
                    # this will eventually be used to select game presets by name
                    # for now, it will just cause an error
                    print(  "ERROR!: Invalid usage (" + arg + ")!\n" +
                            "Use `chocolate-box --help` for more information.", ' ', '\n', file = sys.stderr)
                    sys.exit(4) # invalid usage (not an option); exit with code 4
            else:
                print("ERROR!: Invalid option character length (" + arg + ")!")
                sys.exit(3) # invalid option character length; exit with code 3


        # create Gtk builder
        self.builder = Gtk.Builder()


        # determine if using local or system window icon
        self.window_icon = ""
        if os.path.isfile(self.LOCAL_ICON):
            self.window_icon = self.LOCAL_ICON
        elif os.path.isfile(self.SYSTEM_ICON):
            self.window_icon = self.SYSTEM_ICON
        else:
            warning_message = "WARNING!: Could not find a window icon to use!"
            print(warning_message)
            self.create_simple_message_dialog(warning_message, "Chocolate Box - Warning")


        # determine if using local or system about logo
        self.about_logo = ""
        if os.path.isfile(self.LOCAL_LOGO):
            self.about_logo = self.LOCAL_LOGO
        elif os.path.isfile(self.SYSTEM_LOGO):
            self.about_logo = self.SYSTEM_LOGO
        else:
            warning_message = "WARNING!: Could not find an about logo to use!"
            print(warning_message)
            self.create_simple_message_dialog(warning_message, "Chocolate Box - Warning")


        # determine if using local or system glade file
        if os.path.isfile(self.LOCAL_GLADE):
            self.gladefile = self.LOCAL_GLADE
        elif os.path.isfile(self.SYSTEM_GLADE):
            self.gladefile = self.SYSTEM_GLADE
        else:
            error_message = "WARNING!: Could not find the UI template!"
            print(error_message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(warning_message, "Chocolate Box - Error")
            sys.exit(11) # glade file not found; exit with code 11


        # configure builder and connect signals
        self.builder.add_from_file(self.gladefile)
        self.builder.connect_signals(self)
        

        # update selection lists
        self.update_iwad_list()
        self.update_pwad_list()

        
        # get main window
        self.window = self.builder.get_object("selection_window")
        
        
        # set main window's icon
        if self.window_icon != "":
            self.window.set_icon_from_file(self.window_icon)
        else:
            self.window.set_icon_name("window")

        
        # present main window
        self.window.show_all()


    # Returns properties from a config file as a dictionary.
    def read_config(self, file_path: str) -> {}:
        config = {}

        if os.path.isfile(file_path):
            try:
                with open(file_path, "r") as file:
                    for line in file.readlines():
                        # TODO: implement
                        pass
            except Exception as e:
                error_message = "ERROR!: Something happened while trying to read configuration file (" + file_path + ")!"
                print(str(e) + "\n" + error_message)
                self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                sys.exit(5) # config file read was interrupted; exit with code 5

        return config

    
    # Updates the list of IWADs in the selection window.
    # Returns a dictionary of the IWAD paths.
    def update_iwad_list(self) -> {}:
        if not os.path.isfile(self.iwads_file):
            # no IWADs file
            message = ( "Chocolate Box could not find an IWADs file.\n" +
                        "A new IWADs file will be created in the configuration directory.")
            print(message)
            self.create_simple_message_dialog(message)

            iwads_path = Path(self.iwads_file) # create Path object
            iwads_path.parent.mkdir(exist_ok = True, parents = True) # create parent directory if needed
            iwads_path.write_text("[Chocolate Box IWADs]\n") # write identification line
        else:
            # IWADs file exists
            listbox = self.builder.get_object("iwad_listbox") # get the ListBox widget
            iwad_paths = {} # create iwad path dictionary
            exec_paths = {} # create exec path dictionary

            try:
                with open(self.iwads_file, "r") as file:
                    iwad_index = 0
                    for iwad in file.readlines():
                        if iwad_index == 0 and iwad != "":
                            if not (iwad == "[Chocolate Box IWADs]" or iwad[:-1] == "[Chocolate Box IWADs]"): # check if identification line exists
                                print("WARNING!: Chocolate Box's IWADs file is not valid" + ((" (" + self.iwads_file + ")!") if self.verbose else "!"))
                                self.create_simple_message_dialog("WARNING!: Chocolate Box's IWADs file is not valid!", "Chocolate Box - Warning")
                                return {}
                            for child in listbox.get_children():
                                listbox.remove(child) # clear listbox items
                            iwad_index += 1
                            continue # skip identification line
                        
                       
                        if iwad[len(iwad) - 1] == '\n':
                            iwad = iwad[:-1] # remove new line

                        iwad_elements = iwad.split(':')
                        if len(iwad_elements) < 3:
                            error_message = (   "ERROR!: There is a problem with your IWADs file on line " + str(iwad_index + 1) + "!\n" +
                                                "Expected to find \":\" between three elements, but this condition was not met.")
                            print(error_message, ' ', '\n', file = sys.stderr)
                            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                            sys.exit(8) # less than 3 elements found on current line; exit with code 8


                        # create new label for the current IWAD and add it to the listbox
                        label = Gtk.Label(label = iwad_elements[0])
                        label.show()
                        listbox.add(label)


                        if iwad_paths.get(iwad_elements[0], "") != "":
                            error_message = "ERROR!: Two or more IWADs share the same name in Chocolate Box's IWADs file (" + iwad_elements[0] + ")!"
                            print(error_message, ' ', '\n', file = sys.stderr)
                            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                            sys.exit(9) # duplicate IWAD names: exit with code 9


                        # add IWAD path and exec to dictionaries
                        iwad_paths[iwad_elements[0]] = iwad_elements[1]
                        exec_paths[iwad_elements[0]] = iwad_elements[2]

                        iwad_index += 1
                    
                    if iwad_index > 0:
                        listbox_row = listbox.get_row_at_index(0)
                        if listbox_row != None:
                            listbox.select_row(listbox_row)
                            listbox_row.grab_focus()

            except Exception as e:
                print(str(e) + "\nERROR!: Something happened while trying to read the file that tracks IWADs (" + self.iwads_file + ")!", ' ', '\n', file = sys.stderr)
                sys.exit(6) # iwad file reading interrupted; exit with code 6

            self.iwad_paths = iwad_paths # set iwad path list
            self.exec_paths = exec_paths # set exec path list


    # Updates the list of PWADs in the selection window.
    # Returns a dictionary of the PWAD paths.
    def update_pwad_list(self) -> {}:
        if not os.path.isfile(self.pwads_file):
            # no PWADs file
            message = ( "Chocolate Box could not find a PWADs file.\n" +
                        "A new PWADs file will be created in the configuration directory.")
            print(message)
            self.create_simple_message_dialog(message)

            pwads_path = Path(self.pwads_file) # create Path object
            pwads_path.parent.mkdir(exist_ok = True, parents = True) # create parent directory if needed
            pwads_path.write_text("[Chocolate Box PWADs]\n") # write identification line
        else:
            # PWADs file exists
            listbox = self.builder.get_object("pwad_listbox") # get the ListBox widget
            pwad_paths = {} # create path dictionary to be returned

            try:
                with open(self.pwads_file, "r") as file:
                    pwad_index = 0
                    for pwad in file.readlines():
                        if pwad_index == 0 and pwad != "":
                            if not (pwad == "[Chocolate Box PWADs]" or pwad[:-1] == "[Chocolate Box PWADs]"): # check if identification line exists
                                print("WARNING!: Chocolate Box's PWADs file is not valid" + ((" (" + self.pwads_file + ")!") if self.verbose else "!"))
                                self.create_simple_message_dialog("WARNING!: Chocolate Box's IWADs file is not valid!", "Chocolate Box - Warning")
                                return {}
                            pwad_index += 1
                            continue # skip identification line
                        elif pwad_index == 1 and pwad != "":
                            for child in listbox.get_children():
                                listbox.remove(child) # clear listbox items
                       
                        if pwad[len(pwad) - 1] == '\n':
                            pwad = pwad[:-1] # remove new line

                        pwad_elements = pwad.split('=')
                        if len(pwad_elements) < 2:
                            error_message = (   "ERROR!: There is a problem with your PWADs file on line " + str(pwad_index + 1) + "!\n" +
                                                "Expected to find \"=\" between two elements, but this condition was not met.")
                            print(error_message, ' ', '\n', file = sys.stderr)
                            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                            sys.exit(8) # only 1 element found on line; exit with code 8


                        # create new label for the current PWAD and add it to the listbox
                        label = Gtk.Label(label = pwad_elements[0])
                        listbox.add(label)


                        if pwad_paths.get(pwad_elements[0], "") != "":
                            error_message = "ERROR!: Two or more PWADs share the same name in Chocolate Box's PWADs file (" + pwad_elements[0] + ")!"
                            print(error_message, ' ', '\n', file = sys.stderr)
                            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                            sys.exit(9) # duplicate PWAD names: exit with code 9


                        # add PWAD path to dictionary to be returned
                        pwad_paths[pwad_elements[0]] = pwad_elements[1]
                        
                        pwad_index += 1

            except Exception as e:
                print(str(e) + "\nERROR!: Something happened while trying to read the file that tracks PWADs (" + self.pwads_file + ")!", ' ', '\n', file = sys.stderr)
                sys.exit(10) # pwad file reading interrupted; exit with code 10

            return pwad_paths # return path list


    # Prints the help text.
    def print_help(self):
        print("\nUsage: `chocolate-box [options...]`")
        print("\nOptions:")
        print("  -h, --help\t\tPrints the help text.")
        print("  --version\t\tPrints the current version.")
        print("  --verbose\t\tPrints extra information in the terminal.\n")


    # Prints the current version information.
    def print_version(self):
        print("\nChocolate Box (chocolate-box)")
        print("Version " + self.APP_VERSION)
        print("Created by Nicholas Girga\n")

    
    # Called when the selection window is destroyed.
    def on_selection_window_destroy(self, object, data = None):
        Gtk.main_quit() # quit Gtk


    # Will create a simple message dialog.
    def create_simple_message_dialog(self, text: str, title = "Chocolate Box", yesno = False, window = None):
        # create dialog and give it a title
        message = Gtk.MessageDialog(parent = window, flags = 0, message_type = Gtk.MessageType.INFO, buttons = Gtk.ButtonsType.YES_NO if yesno else Gtk.ButtonsType.OK, text = text)
        message.set_title(title)

        #  set window icon
        if self.window_icon != "":
            message.set_icon_from_file(self.window_icon)
        else:
            message.set_icon_name("window")

        # run dialog, destory it when it exits, and return the response
        response = message.run()
        message.destroy()
        return response


    # Informs user of incomplete features.
    def not_implemented(self):
        self.create_simple_message_dialog("This feature has not been implemented yet!", "Chocolate Box - Error")


    # Called when the launch button is clicked.
    def on_launch_button_clicked(self, object, data = None):
        listbox = self.builder.get_object("iwad_listbox")
        selection = listbox.get_selected_row()
        iwad_path = ""
        exec_path = ""

        if selection != None:
            selection_text = selection.get_child().get_text()
            iwad_path = self.iwad_paths.get(selection_text, "")
            exec_path = self.exec_paths.get(selection_text, "")

        command = []
        if exec_path == "":
            command = [ "/usr/bin/env", "chocolate-doom" ] # construct launch command
        else:
            command = [ exec_path ]

        if iwad_path != "":
            command += ["-iwad", iwad_path]

        window = self.builder.get_object("selection_window") # get window object

        if window:
            if self.launch_behavior == self.LaunchBehavior.MINIMIZE or self.launch_behavior == self.LaunchBehavior.STAY_MINIMIZED:
                window.iconify() # minimize launcher
            elif self.launch_behavior == self.LaunchBehavior.EXIT:
                window.hide() # hide launcher


            if self.launch_behavior != self.LaunchBehavior.NONE:
                while Gtk.events_pending():
                    Gtk.main_iteration() # wait for launcher to finish UI execution before launching
        
        if self.verbose:
            print("Launching with command: " + str(command))
        # start Chocolate DOOM
        try:
            subprocess.run(command, capture_output = not self.verbose)
        except Exception as e:
            warning_message = "WARNING!: Chocolate DOOM threw an exception!"
            print(str(e) + "\n" + warning_message)
            self.create_simple_message_dialog(warning_message, "Chocolate Box - Warning")


        if window:
            if self.launch_behavior == self.LaunchBehavior.MINIMIZE:
                window.present() # present launcher
            elif self.launch_behavior == self.LaunchBehavior.EXIT:
                window.close() # exit launcher


    # Called when the settings button is clicked.
    def on_settings_button_clicked(self, object, data = None):
        listbox = self.builder.get_object("iwad_listbox")
        selection = listbox.get_selected_row()
        exec_path = ""

        # check if there is a selection
        if selection != None:
            selection_text = selection.get_child().get_text()
            exec_path = self.exec_paths.get(selection_text, "")
        else:
            message = "You must select an IWAD before pressing the settings button!"
            print(message)
            self.create_simple_message_dialog(message)
            return

        # check if exec path could be found
        if exec_path == "":
            error_message = "ERROR!: Could not get executable path!"
            print(error_message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
            return

        # run setup
        try:
            subprocess.run([exec_path + "-setup"], capture_output = not self.verbose)
        except Exception as e:
            error_message = "ERROR!: Something happened while trying to run the setup for the selected IWAD's executable!"
            print(str(e) + error_message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")

    
    # Opens the add IWAD window.
    def open_add_iwad_window(self):
        # get widgets
        add_iwad_window = self.builder.get_object("add_iwad_window")
        iwad_name = self.builder.get_object("iwad_name")
        iwad_file = self.builder.get_object("iwad_file")
       
        # set window icon
        if self.window_icon != "":
            add_iwad_window.set_icon_from_file(self.window_icon)
        else:
            add_iwad_window.set_icon_name("window")

        # reset settings
        iwad_name.set_text("")
        iwad_file.unselect_all()
        iwad_file.set_filename("")

        # present window
        add_iwad_window.show_all()


    # Opens the add PWAD window.
    def open_add_pwad_window(self):
        # get widgets
        add_pwad_window = self.builder.get_object("add_pwad_window")
        pwad_name = self.builder.get_object("pwad_name")
        pwad_file = self.builder.get_object("pwad_file")
        pwad_method = self.builder.get_object("pwad_method")

        # set window icon
        if self.window_icon != "":
            add_pwad_window.set_icon_from_file(self.window_icon)
        else:
            add_pwad_window.set_icon_name("window")

        # reset settings
        pwad_name.set_text("")
        pwad_file.unselect_all()
        pwad_file.set_filename("")
        pwad_method.set_active(0)
    
        # present window
        add_pwad_window.show_all()


    # Called when the add button is clicked.
    def on_add_button_clicked(self, object, data = None):
        # determine if adding IWAD or PWAD
        list_stack = self.builder.get_object("list_stack")
        selected_stack = list_stack.get_visible_child_name()
        
        
        # show the right add window for the selected tab
        if selected_stack == "IWADs":
            self.open_add_iwad_window()
        elif selected_stack == "PWADs":
            self.open_add_pwad_window()
        else:
            sys.exit(-1) # selected stack's name is not expected; exit with code -1


    # Called when the remove button is clicked.
    def on_remove_button_clicked(self, object, data = None):
        # determine if removing IWAD or PWAD
        stack_switcher = self.builder.get_object("stack_switcher")
        selected_stack = stack_switcher.get_stack().get_visible_child_name()


        if selected_stack == "IWADs":
            listbox = self.builder.get_object("iwad_listbox")

            selection = listbox.get_selected_row()
            
            if selection == None:
                message = "No IWAD is selected for removal!"
                print(message)
                self.create_simple_message_dialog(message)
                return

            selection_text = selection.get_child().get_text()
        
            if self.create_simple_message_dialog("Are you sure you want to remove the \"" + selection_text + "\" IWAD from the list?", "Chocolate Box", True) != Gtk.ResponseType.YES:
                return

            lines = [] # create empty lines list to be filled

            try:
                with open(self.iwads_file, "r") as file:
                    lines = file.readlines() # store lines from file
            except Exception as e:
                error_message = "ERROR!: Something happened while trying to read the IWADs file!"
                print(str(e) + "\n" + error_message, ' ', '\n', file = sys.stderr)
                self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                return

            try:
                with open(self.iwads_file, "w") as file:
                    for line in lines:
                        if line[:len(selection_text)] == selection_text:
                            continue # skip line that starts with the selected name    
                        file.write(line) # write stored lines to empty file
            except Exception as e:
                error_message = "ERROR!: Something happened while trying to write to the IWADs file!"
                print(str(e) + "\n" + error_message)
                self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
                return

            self.update_iwad_list()

            self.create_simple_message_dialog("Removed the \"" + selection_text + "\" IWAD from the list!")

        elif selected_stack == "PWADs":
            self.create_simple_message_dialog("Removing a PWADs is a work in progress...")
        else:
            sys.exit(-1) # selected stack's name is not expected; exit with code -1


    # Called when the move up button is clicked.
    def on_move_up_button_clicked(self, object, data = None):
        # TODO: implement
        self.not_implemented()


    # Called when the move down button is clicked.
    def on_move_down_button_clicked(self, object, data = None):
        # TODO: implement
        self.not_implemented()


    # Called when the IWAD add confirmation button is clicked.
    def on_iwad_add_confirm_button_clicked(self, object, data = None):
        # get widgets
        window = self.builder.get_object("add_iwad_window")
        iwad_name = self.builder.get_object("iwad_name")
        iwad_file = self.builder.get_object("iwad_file")
        exec_path = self.builder.get_object("exec_path")

        # get information
        iwad_name_str = iwad_name.get_text()
        iwad_file_str = iwad_file.get_filename()
        exec_path_str = exec_path.get_active_text()
        if iwad_file_str == None:
            iwad_file_str = ""

        # check if any elements are empty
        if iwad_name_str == "" or exec_path_str == "":
            message = "ERROR!: IWAD name and executable cannot be left empty!"
            print(message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(message, "Chocolate Box - Error")
            return

        # check if any elements contain colons
        if ":" in iwad_name_str or ":" in exec_path_str or (iwad_file_str != "" and iwad_file_str != None) and ":" in iwad_file_str:
            error_message = "ERROR!: None of the IWAD elements can contain \":\"!"
            print(error_message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
            return

        try:
            with open(self.iwads_file, "r") as file:
                for line in file.readlines():
                    if line[:len(iwad_name_str)] == iwad_name_str:
                        message = "An IWAD with the specified name already exists!"
                        print(message)
                        self.create_simple_message_dialog(message)
                        return
        except Exception as e:
            error_message = "ERROR!: Something happened while trying to check the IWADs file for duplicate names!"
            print(str(e) + "\n" + error_message, ' ', '\n', file = sys.stderr)
            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")
            return

        try:
            with open(self.iwads_file, "a") as file:
                file.write(iwad_name_str + ":" + iwad_file_str + ":" + exec_path_str + "\n") # write IWAD information
        except Exception as e:
            error_message = "ERROR!: Something happened while trying to append the IWAD information to the IWADs file!"
            print(str(e) + "\n" + error_message)
            self.create_simple_message_dialog(error_message, "Chocolate Box - Error")

        self.update_iwad_list()
        window.hide()


    # Called when the cancel button in the add IWAD dialog is pressed.
    def on_iwad_cancel_button_clicked(self, object, data = None):
        window = self.builder.get_object("add_iwad_window")
        window.hide()


    # Called when the PWAD add confirmation button is clicked.
    def on_pwad_add_confirm_button_clicked(self, object, data = None):
        # get widgets
        window = self.builder.get_object("add_pwad_window")

        self.create_simple_message_dialog("... Pretend I added something. This feature is still in progress!")

        window.hide()

    
    # Called when the cancel button in the add PWAD dialog is pressed.
    def on_pwad_cancel_button_clicked(self, object, data = None):
        window = self.builder.get_object("add_pwad_window")
        window.hide()

    
    # Called when the about button is clicked.
    def on_about_button_clicked(self, object, data = None):
        # create about dialog
        about = Gtk.AboutDialog()

        # set app information in about dialog
        about.set_program_name("Chocolate Box")
        about.set_version(self.APP_VERSION)
        about.set_property("authors", ["Nicholas Girga"])
        about.set_comments("Simple GUI for Chocolate DOOM")
        about.set_website("http://gitlab.com/nickgirga/chocolate-box")
        about.set_website_label("gitlab.com/nickgirga/chocolate-box")
        
        # set license in about dialog
        about.set_license_type(Gtk.License.MIT_X11)

        # set logo in about dialog
        if self.about_logo != "":
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(self.about_logo)
            about.set_logo(pixbuf)
        else:
            about.set_logo_icon_name("window")

        # set icon in about dialog
        if self.window_icon != "":
            about.set_icon_from_file(self.window_icon)
        else:
            about.set_icon_name("window")

        # run and destroy about dialog
        about.run()
        about.destroy()


    # Called when add_iwad_window is deleted.
    def on_add_iwad_window_delete_event(self, object, data = None):
        object.hide()
        return True


    # Called when add_pwad_window is deleted.
    def on_add_pwad_window_delete_event(self, object, data = None):
        object.hide()
        return True


    # Called when a key is pressed with the selection window active.
    def on_selection_window_key_press_event(self, object, event):
        # shift selected item up/down if holding shift while pressing arrow keys
        if event.state == Gdk.ModifierType.SHIFT_MASK:
            if event.keyval == Gdk.KEY_Up:
                # TODO: implement shift selected item up
                pass
            elif event.keyval == Gdk.KEY_Down:
                # TODO: implement shift selected item down
                pass

        # ignore key modifiers
        if not event.state == 0:
            return

        # get widgets
        list_stack = self.builder.get_object("list_stack")
        iwad_listbox = self.builder.get_object("iwad_listbox")
        pwad_listbox = self.builder.get_object("pwad_listbox")
       
        # find the selected stack
        selected_stack = list_stack.get_visible_child_name()
        
        if event.type == Gdk.EventType.KEY_PRESS:
            # swap IWADs/PWADs menus when the left/right arrows are pressed
            if event.keyval == Gdk.KEY_Left or event.keyval == Gdk.KEY_Right:
                if selected_stack == "PWADs":
                    list_stack.set_visible_child_name("IWADs")
                    iwad_listbox.grab_focus()
                elif selected_stack == "IWADs":
                    list_stack.set_visible_child_name("PWADs")
                    pwad_listbox.grab_focus()
                else:
                    sys.exit(-1) # selected stack's name is not expected; exit with code -1


            # quit if ESCAPE is pressed
            if event.keyval == Gdk.KEY_Escape:
                Gtk.main_quit()

            
            # "press add button" if A is pressed
            if event.keyval == Gdk.KEY_a:
                self.on_add_button_clicked(None)
            

            # add IWAD if I is pressed
            if event.keyval == Gdk.KEY_i:
                self.open_add_iwad_window()

            
            # add PWAD if P is pressed
            if event.keyval == Gdk.KEY_p:
                self.open_add_pwad_window() 


            # "press remove button" if R, DELETE, or BACKSPACE is pressed
            if event.keyval == Gdk.KEY_r or event.keyval == Gdk.KEY_Delete or event.keyval == Gdk.KEY_KP_Delete or event.keyval == Gdk.KEY_BackSpace:
                self.on_remove_button_clicked(None)


# Start.
if __name__ == "__main__":
    try:
        main = Main() # create new instance of main class
        Gtk.main() # Initialize Gtk
    except KeyboardInterrupt:
        print("Quitting (user request)...")
        sys.exit(0) # exit on KeyboardInterrupt
    except Exception as e:
        print(str(e))
        sys.exit(7) # main instance interrupted; exit with code 7
